//! Client library for the JSON-RPC-based Project Manager service.

#![warn(missing_docs)]
#![warn(trivial_casts)]
#![warn(trivial_numeric_casts)]
#![warn(unused_import_braces)]
#![warn(unused_qualifications)]
#![warn(unsafe_code)]
#![warn(missing_copy_implementations)]
#![warn(missing_debug_implementations)]

use enso_prelude::*;

use crate::common::UTCDateTime;
use json_rpc::api::Result;
use json_rpc::Handler;
use json_rpc::make_rpc_methods;
use json_rpc::make_param_map;
use json_rpc::make_arg;
use futures::Stream;
use serde::Serialize;
use serde::Deserialize;
use std::future::Future;
use uuid::Uuid;



// =============
// === Event ===
// =============

/// Event emitted by the Project Manager `Client`.
pub type Event = json_rpc::handler::Event<Notification>;



// ====================
// === Notification ===
// ====================

/// Notification generated by the Project Manager.
#[derive(Clone,Copy,Debug,PartialEq)]
#[derive(Serialize, Deserialize)]
#[serde(tag="method", content="params")]
pub enum Notification {}



// ===================
// === RPC Methods ===
// ===================

make_rpc_methods! {
/// An interface containing all the available project management operations.
trait Client {
    /// Requests that the project picker open a specified project. This operation also
    /// includes spawning an instance of the language server open on the specified project.
    #[MethodInput=OpenProjectInput,camelCase=openProject,result=open_project_result,set_result=set_open_project_result]
    fn open_project(&self, project_id:Uuid) -> IpWithSocket;

    /// Requests that the project picker close a specified project. This operation
    /// includes shutting down the language server gracefully so that it can persist state to disk
    /// as needed.
    #[MethodInput=CloseProjectInput,camelCase=closeProject,result=close_project_result,set_result=set_close_project_result]
    fn close_project(&self, project_id:Uuid) -> ();

    /// Requests that the project picker lists the user's most recently opened
    /// projects.
    #[MethodInput=ListRecentInput,camelCase=listRecent,result=list_recent_result,set_result=set_list_recent_result]
    fn list_recent(&self, number_of_projects:u32) -> Vec<ProjectMetaData>;

    /// Requests the creation of a new project.
    #[MethodInput=CreateProjectInput,camelCase=createProject,result=create_project_result,set_result=set_create_project_result]
    fn create_project(&self, name:String) -> Uuid;

    /// Requests the deletion of a project.
    #[MethodInput=DeleteProjectInput,camelCase=deleteProject,result=delete_project_result,set_result=set_delete_project_result]
    fn delete_project(&self, project_id:Uuid) -> ();

    /// Requests a list of sample projects that are available to the user.
    #[MethodInput=ListSampleInput,camelCase=listSample,result=list_sample_result,set_result=set_list_sample_result]
    fn list_sample(&self, number_of_projects:u32) -> Vec<ProjectMetaData>;
}
}

/// IP address with host and port.
#[derive(Debug,Clone,Serialize,Deserialize,PartialEq)]
pub struct IpWithSocket {
    host : String,
    port : u16
}

/// This type represents information about a project.
#[derive(Debug,Clone,Serialize,Deserialize,PartialEq)]
pub struct ProjectMetaData {
    name        : String,
    id          : Uuid,
    last_opened : UTCDateTime
}



// ========================
// === MockClient tests ===
// ========================

#[cfg(test)]
mod mock_client_tests {
    use super::API;
    use super::MockClient;
    use super::IpWithSocket;
    use super::ProjectMetaData;
    use uuid::Uuid;
    use json_rpc::error::RpcError;
    use json_rpc::messages::Error;
    use json_rpc::Result;
    use std::future::Future;
    use utils::test::poll_future_output;

    fn error<T>(message:&str) -> Result<T> {
        let err = Error {
            code : 1,
            data : None,
            message : message.to_string()
        };
        Err(RpcError::RemoteError(err))
    }

    fn result<T,F:Future<Output = Result<T>>>(fut:F) -> Result<T> {
        let mut fut = Box::pin(fut);
        poll_future_output(&mut fut).expect("Promise isn't ready")
    }

    #[test]
    fn project_life_cycle() {
        let mock_client             = MockClient::default();
        let expected_uuid           = Uuid::default();
        let host                    = "localhost".to_string();
        let port                    = 30500;
        let expected_ip_with_socket = IpWithSocket {host,port};
        mock_client.set_create_project_result("HelloWorld".into(),Ok(expected_uuid.clone()));
        mock_client.set_open_project_result(expected_uuid.clone(), Ok(expected_ip_with_socket.clone()));
        mock_client.set_close_project_result(expected_uuid.clone(), error("Project isn't open."));
        mock_client.set_delete_project_result(expected_uuid.clone(), error("Project doesn't exist."));

        let delete_result = mock_client.delete_project(expected_uuid.clone());
        result(delete_result).expect_err("Project shouldn't exist.");

        let uuid = mock_client.create_project("HelloWorld".into());
        let uuid = result(uuid).expect("Couldn't create project");
        assert_eq!(uuid, expected_uuid);

        let close_result = result(mock_client.close_project(uuid.clone()));
        close_result.expect_err("Project shouldn't be open.");

        let ip_with_socket = result(mock_client.open_project(uuid.clone()));
        let ip_with_socket = ip_with_socket.expect("Couldn't open project");
        assert_eq!(ip_with_socket, expected_ip_with_socket);

        mock_client.set_close_project_result(expected_uuid.clone(), Ok(()));
        result(mock_client.close_project(uuid)).expect("Couldn't close project.");

        mock_client.set_delete_project_result(expected_uuid.clone(), Ok(()));
        result(mock_client.delete_project(uuid)).expect("Couldn't delete project.");
    }

    #[test]
    fn list_projects() {
        let mock_client = MockClient::default();
        let project1    = ProjectMetaData {
            name        : "project1".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2020-01-07T21:25:26Z").unwrap()
        };
        let project2 = ProjectMetaData {
            name        : "project2".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2020-02-02T13:15:20Z").unwrap()
        };
        let expected_recent_projects = vec![project1,project2];
        let sample1 = ProjectMetaData {
            name        : "sample1".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2019-11-23T05:30:12Z").unwrap()
        };
        let sample2 = ProjectMetaData {
            name        : "sample2".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2019-12-25T00:10:58Z").unwrap()
        };
        let expected_sample_projects = vec![sample1,sample2];
        mock_client.set_list_recent_result(2,Ok(expected_recent_projects.clone()));
        mock_client.set_list_sample_result(2,Ok(expected_sample_projects.clone()));

        let recent_projects = result(mock_client.list_recent(2)).expect("Couldn't get recent projects.");
        assert_eq!(recent_projects, expected_recent_projects);
        let sample_projects = result(mock_client.list_sample(2)).expect("Couldn't get sample projects.");
        assert_eq!(sample_projects, expected_sample_projects);
    }
}



// ====================
// === Client tests ===
// ====================

#[cfg(test)]
mod remote_client_tests {
    use super::*;

    use json_rpc::messages::Message;
    use json_rpc::messages::RequestMessage;
    use json_rpc::test_util::transport::mock::MockTransport;
    use serde_json::json;
    use serde_json::Value;
    use std::future::Future;
    use utils::test::poll_future_output;
    use futures::task::LocalSpawnExt;

    struct Fixture {
        transport : MockTransport,
        client    : Client,
        executor  : futures::executor::LocalPool,
    }

    fn setup_fm() -> Fixture {
        let transport = MockTransport::new();
        let client    = Client::new(transport.clone());
        let executor  = futures::executor::LocalPool::new();
        executor.spawner().spawn_local(client.runner()).unwrap();
        Fixture {transport,client,executor}
    }

    /// Tests making a request using file manager:
    /// * creates PM client and uses `make_request` to make a request
    /// * checks that request is made for `expected_method`
    /// * checks that request input is `expected_input`
    /// * mocks receiving a response from server with `result`
    /// * checks that FM-returned Future yields `expected_output`
    fn test_request<Fun, Fut, T>
    ( make_request:Fun
      , expected_method:&str
      , expected_input:Value
      , result:Value
      , expected_output:T )
        where Fun : FnOnce(&mut Client) -> Fut,
              Fut : Future<Output = Result<T>>,
              T   : Debug + PartialEq {
        let mut fixture = setup_fm();
        let mut fut     = Box::pin(make_request(&mut fixture.client));

        let request = fixture.transport.expect_message::<RequestMessage<Value>>();
        assert_eq!(request.method, expected_method);
        assert_eq!(request.params, expected_input);

        let response = Message::new_success(request.id, result);
        fixture.transport.mock_peer_message(response);
        fixture.executor.run_until_stalled();
        let output = poll_future_output(&mut fut).unwrap().unwrap();
        assert_eq!(output, expected_output);
    }

    #[test]
    fn test_requests() {
        let unit_json               = json!(null);
        let project_id              = Uuid::default();
        let project_id_json         = serde_json::to_value(&project_id).unwrap();
        let project_id_param_json   = json!({"projectId":project_id});
        let ip_with_address         = IpWithSocket { host: "localhost".to_string(), port: 27015 };
        let ip_with_address_json    = serde_json::to_value(&ip_with_address).unwrap();
        let project_name            = String::from("HelloWorld");
        let project_name_json       = json!({"name":serde_json::to_value(&project_name).unwrap()});
        let number_of_projects      = 2;
        let number_of_projects_json = json!({"numberOfProjects":number_of_projects});
        let project1                = ProjectMetaData {
            name        : "project1".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2020-01-07T21:25:26Z").unwrap()
        };
        let project2 = ProjectMetaData {
            name        : "project2".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2020-02-02T13:15:20Z").unwrap()
        };
        let project_list      = vec![project1,project2];
        let project_list_json = serde_json::to_value(&project_list).unwrap();

        test_request(
            |client| client.list_recent(number_of_projects),
            "listRecent",
            number_of_projects_json.clone(),
            project_list_json.clone(),
            project_list.clone()
        );
        test_request(
            |client| client.list_sample(number_of_projects),
            "listSample",
            number_of_projects_json.clone(),
            project_list_json.clone(),
            project_list
        );
        test_request(
            |client| client.open_project(project_id.clone()),
            "openProject",
            project_id_param_json.clone(),
            ip_with_address_json.clone(),
            ip_with_address.clone());
        test_request(
            |client| client.close_project(project_id.clone()),
            "closeProject",
            project_id_param_json.clone(),
            unit_json.clone(),
            ());
        test_request(
            |client| client.delete_project(project_id.clone()),
            "deleteProject",
            project_id_param_json.clone(),
            unit_json.clone(),
            ());
        test_request(
            |client| client.create_project(project_name.clone()),
            "createProject",
            project_name_json.clone(),
            project_id_json.clone(),
            project_id);
    }
}
