//! Client library for the JSON-RPC-based Project Manager service.

#![warn(missing_docs)]
#![warn(trivial_casts)]
#![warn(trivial_numeric_casts)]
#![warn(unused_import_braces)]
#![warn(unused_qualifications)]
#![warn(unsafe_code)]
#![warn(missing_copy_implementations)]
#![warn(missing_debug_implementations)]

use enso_prelude::*;

use crate::common::UTCDateTime;
use json_rpc::api::Result;
use json_rpc::Handler;
use json_rpc::make_rpc_methods;
use json_rpc::make_param_map;
use json_rpc::make_arg;
use futures::Stream;
use serde::Serialize;
use serde::Deserialize;
use std::future::Future;
use uuid::Uuid;



// =============
// === Event ===
// =============

/// Event emitted by the Project Manager `Client`.
pub type Event = json_rpc::handler::Event<Notification>;



// ====================
// === Notification ===
// ====================

/// Notification generated by the Project Manager.
#[derive(Clone,Copy,Debug,PartialEq)]
#[derive(Serialize, Deserialize)]
#[serde(tag="method", content="params")]
pub enum Notification {}



// ===================
// === RPC Methods ===
// ===================

make_rpc_methods! {
/// An interface containing all the available project management operations.
trait Client {
    /// Requests that the project picker open a specified project. This operation also
    /// includes spawning an instance of the language server open on the specified project.
    #[MethodInput=OpenProjectInput,camelCase=openProject,result=open_project_result,set_result=set_open_project_result]
    fn open_project(&self, project_id:Uuid) -> IpWithSocket;

    /// Requests that the project picker close a specified project. This operation
    /// includes shutting down the language server gracefully so that it can persist state to disk
    /// as needed.
    #[MethodInput=CloseProjectInput,camelCase=closeProject,result=close_project_result,set_result=set_close_project_result]
    fn close_project(&self, project_id:Uuid) -> ();

    /// Requests that the project picker lists the user's most recently opened
    /// projects.
    #[MethodInput=ListRecentInput,camelCase=listRecent,result=list_recent_result,set_result=set_list_recent_result]
    fn list_recent(&self, number_of_projects:u32) -> Vec<ProjectMetaData>;

    /// Requests the creation of a new project.
    #[MethodInput=CreateProjectInput,camelCase=createProject,result=create_project_result,set_result=set_create_project_result]
    fn create_project(&self, name:String) -> Uuid;

    /// Requests the deletion of a project.
    #[MethodInput=DeleteProjectInput,camelCase=deleteProject,result=delete_project_result,set_result=set_delete_project_result]
    fn delete_project(&self, project_id:Uuid) -> ();

    /// Requests a list of sample projects that are available to the user.
    #[MethodInput=ListSampleInput,camelCase=listSample,result=list_sample_result,set_result=set_list_sample_result]
    fn list_sample(&self, number_of_projects:u32) -> Vec<ProjectMetaData>;
}
}

/// IP address with host and port.
#[derive(Debug,Clone,Serialize,Deserialize,PartialEq)]
pub struct IpWithSocket {
    host : String,
    port : u16
}

/// This type represents information about a project.
#[derive(Debug,Clone,Serialize,Deserialize,PartialEq)]
pub struct ProjectMetaData {
    name        : String,
    id          : Uuid,
    last_opened : UTCDateTime
}



// ========================
// === MockClient tests ===
// ========================

#[cfg(test)]
mod mock_client_tests {
    use super::Client;
    use super::MockClient;
    use super::IpWithSocket;
    use super::ProjectMetaData;
    use uuid::Uuid;
    use json_rpc::error::RpcError;
    use json_rpc::messages::Error;
    use json_rpc::Result;
    use std::future::Future;
    use utils::test::poll_future_output;

    fn error<T>(message:&str) -> Result<T> {
        let err = Error {
            code : 1,
            data : None,
            message : message.to_string()
        };
        Err(RpcError::RemoteError(err))
    }

    fn result<T,F:Future<Output = Result<T>>>(fut:F) -> Result<T> {
        let mut fut = Box::pin(fut);
        poll_future_output(&mut fut).expect("Promise isn't ready")
    }

    #[test]
    fn project_life_cycle() {
        let mock_client             = MockClient::default();
        let expected_uuid           = Uuid::default();
        let host                    = "localhost".to_string();
        let port                    = 30500;
        let expected_ip_with_socket = IpWithSocket {host,port};
        mock_client.set_create_project_result("HelloWorld".into(),Ok(expected_uuid.clone()));
        mock_client.set_open_project_result(expected_uuid.clone(), Ok(expected_ip_with_socket.clone()));
        mock_client.set_close_project_result(expected_uuid.clone(), error("Project isn't open."));
        mock_client.set_delete_project_result(expected_uuid.clone(), error("Project doesn't exist."));

        let delete_result = mock_client.delete_project(expected_uuid.clone());
        result(delete_result).expect_err("Project shouldn't exist.");

        let uuid = mock_client.create_project("HelloWorld".into());
        let uuid = result(uuid).expect("Couldn't create project");
        assert_eq!(uuid, expected_uuid);

        let close_result = result(mock_client.close_project(uuid.clone()));
        close_result.expect_err("Project shouldn't be open.");

        let ip_with_socket = result(mock_client.open_project(uuid.clone()));
        let ip_with_socket = ip_with_socket.expect("Couldn't open project");
        assert_eq!(ip_with_socket, expected_ip_with_socket);

        mock_client.set_close_project_result(expected_uuid.clone(), Ok(()));
        result(mock_client.close_project(uuid)).expect("Couldn't close project.");

        mock_client.set_delete_project_result(expected_uuid.clone(), Ok(()));
        result(mock_client.delete_project(uuid)).expect("Couldn't delete project.");
    }

    #[test]
    fn list_projects() {
        let mock_client = MockClient::default();
        let project1    = ProjectMetaData {
            name        : "project1".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2020-01-07T21:25:26Z").unwrap()
        };
        let project2 = ProjectMetaData {
            name        : "project2".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2020-02-02T13:15:20Z").unwrap()
        };
        let expected_recent_projects = vec![project1,project2];
        let sample1 = ProjectMetaData {
            name        : "sample1".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2019-11-23T05:30:12Z").unwrap()
        };
        let sample2 = ProjectMetaData {
            name        : "sample2".to_string(),
            id          : Uuid::default(),
            last_opened : chrono::DateTime::parse_from_rfc3339("2019-12-25T00:10:58Z").unwrap()
        };
        let expected_sample_projects = vec![sample1,sample2];
        mock_client.set_list_recent_result(2,Ok(expected_recent_projects.clone()));
        mock_client.set_list_sample_result(2,Ok(expected_sample_projects.clone()));

        let recent_projects = result(mock_client.list_recent(2)).expect("Couldn't get recent projects.");
        assert_eq!(recent_projects, expected_recent_projects);
        let sample_projects = result(mock_client.list_sample(2)).expect("Couldn't get sample projects.");
        assert_eq!(sample_projects, expected_sample_projects);
    }
}



// ==========================
// === RemoteClient tests ===
// ==========================
//
// #[cfg(test)]
// mod remote_client_tests {
//     use super::*;
//     use super::FileKind::RegularFile;
//
//     use json_rpc::messages::Message;
//     use json_rpc::messages::RequestMessage;
//     use json_rpc::test_util::transport::mock::MockTransport;
//     use serde_json::json;
//     use serde_json::Value;
//     use std::future::Future;
//     use utils::test::poll_future_output;
//     use utils::test::poll_stream_output;
//     use futures::task::LocalSpawnExt;
//
//     struct Fixture {
//         transport : MockTransport,
//         client    : RemoteClient,
//         executor  : futures::executor::LocalPool,
//     }
//
//     fn setup_fm() -> Fixture {
//         let transport = MockTransport::new();
//         let client    = RemoteClient::new(transport.clone());
//         let executor  = futures::executor::LocalPool::new();
//         executor.spawner().spawn_local(client.runner()).unwrap();
//         Fixture {transport,client,executor}
//     }
//
//     #[test]
//     fn test_notification() {
//         let mut fixture = setup_fm();
//         let mut events  = Box::pin(fixture.client.events());
//         assert!(poll_stream_output(&mut events).is_none());
//
//         let expected_notification = FilesystemEvent {
//             path : Path::new("./Main.luna"),
//             kind : FilesystemEventKind::Modified,
//         };
//         let notification_text = r#"{
//             "jsonrpc": "2.0",
//             "method": "filesystemEvent",
//             "params": {"path" : "./Main.luna", "kind" : "Modified"}
//         }"#;
//         fixture.transport.mock_peer_message_text(notification_text);
//         assert!(poll_stream_output(&mut events).is_none());
//
//         fixture.executor.run_until_stalled();
//
//         let event = poll_stream_output(&mut events);
//         if let Some(Event::Notification(n)) = event {
//             assert_eq!(n, Notification::FilesystemEvent(expected_notification));
//         } else {
//             panic!("expected notification event");
//         }
//     }
//
//     /// Tests making a request using file manager:
//     /// * creates FM client and uses `make_request` to make a request
//     /// * checks that request is made for `expected_method`
//     /// * checks that request input is `expected_input`
//     /// * mocks receiving a response from server with `result`
//     /// * checks that FM-returned Future yields `expected_output`
//     fn test_request<Fun, Fut, T>
//     ( make_request:Fun
//       , expected_method:&str
//       , expected_input:Value
//       , result:Value
//       , expected_output:T )
//         where Fun : FnOnce(&mut RemoteClient) -> Fut,
//               Fut : Future<Output = Result<T>>,
//               T   : Debug + PartialEq {
//         let mut fixture = setup_fm();
//         let mut fut     = Box::pin(make_request(&mut fixture.client));
//
//         let request = fixture.transport.expect_message::<RequestMessage<Value>>();
//         assert_eq!(request.method, expected_method);
//         assert_eq!(request.params, expected_input);
//
//         let response = Message::new_success(request.id, result);
//         fixture.transport.mock_peer_message(response);
//         fixture.executor.run_until_stalled();
//         let output = poll_future_output(&mut fut).unwrap().unwrap();
//         assert_eq!(output, expected_output);
//     }
//
//     #[test]
//     fn test_requests() {
//         let main                = Path::new("./Main.luna");
//         let target              = Path::new("./Target.luna");
//         let path_main           = json!({"path" : "./Main.luna"});
//         let from_main_to_target = json!({
//             "from" : "./Main.luna",
//             "to"   : "./Target.luna"
//         });
//         let true_json = json!(true);
//         let unit_json = json!(null);
//
//         test_request(
//             |client| client.copy_directory(main.clone(), target.clone()),
//             "copyDirectory",
//             from_main_to_target.clone(),
//             unit_json.clone(),
//             ());
//         test_request(
//             |client| client.copy_file(main.clone(), target.clone()),
//             "copyFile",
//             from_main_to_target.clone(),
//             unit_json.clone(),
//             ());
//         test_request(
//             |client| client.delete_file(main.clone()),
//             "deleteFile",
//             path_main.clone(),
//             unit_json.clone(),
//             ());
//         test_request(
//             |client| client.exists(main.clone()),
//             "exists",
//             path_main.clone(),
//             true_json,
//             true);
//
//         let list_response_json  = json!([          "Bar.luna",           "Foo.luna" ]);
//         let list_response_value = vec!  [Path::new("Bar.luna"),Path::new("Foo.luna")];
//         test_request(
//             |client| client.list(main.clone()),
//             "list",
//             path_main.clone(),
//             list_response_json,
//             list_response_value);
//         test_request(
//             |client| client.move_directory(main.clone(), target.clone()),
//             "moveDirectory",
//             from_main_to_target.clone(),
//             unit_json.clone(),
//             ());
//         test_request(
//             |client| client.move_file(main.clone(), target.clone()),
//             "moveFile",
//             from_main_to_target.clone(),
//             unit_json.clone(),
//             ());
//         test_request(
//             |client| client.read(main.clone()),
//             "read",
//             path_main.clone(),
//             json!("Hello world!"),
//             "Hello world!".into());
//
//         let parse_rfc3339 = |s| {
//             chrono::DateTime::parse_from_rfc3339(s).unwrap()
//         };
//         let expected_attributes = Attributes {
//             creation_time      : parse_rfc3339("2020-01-07T21:25:26Z"),
//             last_access_time   : parse_rfc3339("2020-01-21T22:16:51.123994500+00:00"),
//             last_modified_time : parse_rfc3339("2020-01-07T21:25:26Z"),
//             file_kind          : RegularFile,
//             byte_size          : 125125,
//         };
//         let sample_attributes_json = json!({
//             "creationTime"      : "2020-01-07T21:25:26Z",
//             "lastAccessTime"    : "2020-01-21T22:16:51.123994500+00:00",
//             "lastModifiedTime"  : "2020-01-07T21:25:26Z",
//             "fileKind"          : "RegularFile",
//             "byteSize"          : 125125
//         });
//         test_request(
//             |client| client.status(main.clone()),
//             "status",
//             path_main.clone(),
//             sample_attributes_json,
//             expected_attributes);
//         test_request(
//             |client| client.touch(main.clone()),
//             "touch",
//             path_main.clone(),
//             unit_json.clone(),
//             ());
//         test_request(
//             |client| client.write(main.clone(), "Hello world!".into()),
//             "write",
//             json!({"path" : "./Main.luna", "contents" : "Hello world!"}),
//             unit_json.clone(),
//             ());
//
//         let uuid_value = uuid::Uuid::parse_str("02723954-fbb0-4641-af53-cec0883f260a").unwrap();
//         let uuid_json  = json!("02723954-fbb0-4641-af53-cec0883f260a");
//         test_request(
//             |client| client.create_watch(main.clone()),
//             "createWatch",
//             path_main.clone(),
//             uuid_json.clone(),
//             uuid_value);
//         let watch_id   = json!({
//             "watchId" : "02723954-fbb0-4641-af53-cec0883f260a"
//         });
//         test_request(
//             |client| client.delete_watch(uuid_value.clone()),
//             "deleteWatch",
//             watch_id.clone(),
//             unit_json.clone(),
//             ());
//     }
// }
