// automatically generated by the FlatBuffers compiler, do not modify



use crate::execution_context_generated::*;
use crate::session_generated::*;
use crate::util_generated::*;
use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod org {

  use crate::execution_context_generated::*;
  use crate::session_generated::*;
  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod enso {

  use crate::execution_context_generated::*;
  use crate::session_generated::*;
  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod languageserver {

  use crate::execution_context_generated::*;
  use crate::session_generated::*;
  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod protocol {

  use crate::execution_context_generated::*;
  use crate::session_generated::*;
  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod data {

  use crate::execution_context_generated::*;
  use crate::session_generated::*;
  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod envelope {

  use crate::execution_context_generated::*;
  use crate::session_generated::*;
  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum InboundPayload {
  NONE = 0,
  SESSION_INIT = 1,

}

pub const ENUM_MIN_INBOUND_PAYLOAD: u8 = 0;
pub const ENUM_MAX_INBOUND_PAYLOAD: u8 = 1;

impl<'a> flatbuffers::Follow<'a> for InboundPayload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for InboundPayload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const InboundPayload;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const InboundPayload;
    unsafe { *p }
  }
}

impl flatbuffers::Push for InboundPayload {
    type Output = InboundPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<InboundPayload>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INBOUND_PAYLOAD:[InboundPayload; 2] = [
  InboundPayload::NONE,
  InboundPayload::SESSION_INIT
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_INBOUND_PAYLOAD:[&'static str; 2] = [
    "NONE",
    "SESSION_INIT"
];

pub fn enum_name_inbound_payload(e: InboundPayload) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_INBOUND_PAYLOAD[index as usize]
}

pub struct InboundPayloadUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum OutboundPayload {
  NONE = 0,
  ERROR = 1,
  SESSION_INIT_RESPONSE = 2,
  VISUALISATION_UPDATE = 3,

}

pub const ENUM_MIN_OUTBOUND_PAYLOAD: u8 = 0;
pub const ENUM_MAX_OUTBOUND_PAYLOAD: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for OutboundPayload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for OutboundPayload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const OutboundPayload;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const OutboundPayload;
    unsafe { *p }
  }
}

impl flatbuffers::Push for OutboundPayload {
    type Output = OutboundPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<OutboundPayload>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OUTBOUND_PAYLOAD:[OutboundPayload; 4] = [
  OutboundPayload::NONE,
  OutboundPayload::ERROR,
  OutboundPayload::SESSION_INIT_RESPONSE,
  OutboundPayload::VISUALISATION_UPDATE
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_OUTBOUND_PAYLOAD:[&'static str; 4] = [
    "NONE",
    "ERROR",
    "SESSION_INIT_RESPONSE",
    "VISUALISATION_UPDATE"
];

pub fn enum_name_outbound_payload(e: OutboundPayload) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_OUTBOUND_PAYLOAD[index as usize]
}

pub struct OutboundPayloadUnionTableOffset {}
pub enum InboundMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InboundMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InboundMessage<'a> {
    type Inner = InboundMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InboundMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InboundMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InboundMessageArgs<'args>) -> flatbuffers::WIPOffset<InboundMessage<'bldr>> {
      let mut builder = InboundMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      if let Some(x) = args.correlationId { builder.add_correlationId(x); }
      if let Some(x) = args.requestId { builder.add_requestId(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_REQUESTID: flatbuffers::VOffsetT = 4;
    pub const VT_CORRELATIONID: flatbuffers::VOffsetT = 6;
    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn requestId(&self) -> &'a super::util::EnsoUUID {
    self._tab.get::<super::util::EnsoUUID>(InboundMessage::VT_REQUESTID, None).unwrap()
  }
  #[inline]
  pub fn correlationId(&self) -> Option<&'a super::util::EnsoUUID> {
    self._tab.get::<super::util::EnsoUUID>(InboundMessage::VT_CORRELATIONID, None)
  }
  #[inline]
  pub fn payload_type(&self) -> InboundPayload {
    self._tab.get::<InboundPayload>(InboundMessage::VT_PAYLOAD_TYPE, Some(InboundPayload::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(InboundMessage::VT_PAYLOAD, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_session_init(&self) -> Option<super::session::SessionInit<'a>> {
    if self.payload_type() == InboundPayload::SESSION_INIT {
      self.payload().map(|u| super::session::SessionInit::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct InboundMessageArgs<'a> {
    pub requestId: Option<&'a  super::util::EnsoUUID>,
    pub correlationId: Option<&'a  super::util::EnsoUUID>,
    pub payload_type: InboundPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for InboundMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        InboundMessageArgs {
            requestId: None, // required field
            correlationId: None,
            payload_type: InboundPayload::NONE,
            payload: None, // required field
        }
    }
}
pub struct InboundMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InboundMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_requestId(&mut self, requestId: &'b  super::util::EnsoUUID) {
    self.fbb_.push_slot_always::<&super::util::EnsoUUID>(InboundMessage::VT_REQUESTID, requestId);
  }
  #[inline]
  pub fn add_correlationId(&mut self, correlationId: &'b  super::util::EnsoUUID) {
    self.fbb_.push_slot_always::<&super::util::EnsoUUID>(InboundMessage::VT_CORRELATIONID, correlationId);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: InboundPayload) {
    self.fbb_.push_slot::<InboundPayload>(InboundMessage::VT_PAYLOAD_TYPE, payload_type, InboundPayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InboundMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InboundMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InboundMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InboundMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, InboundMessage::VT_REQUESTID,"request_id");
    self.fbb_.required(o, InboundMessage::VT_PAYLOAD,"payload");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OutboundMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OutboundMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutboundMessage<'a> {
    type Inner = OutboundMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OutboundMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OutboundMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OutboundMessageArgs<'args>) -> flatbuffers::WIPOffset<OutboundMessage<'bldr>> {
      let mut builder = OutboundMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      if let Some(x) = args.correlationId { builder.add_correlationId(x); }
      if let Some(x) = args.requestId { builder.add_requestId(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_REQUESTID: flatbuffers::VOffsetT = 4;
    pub const VT_CORRELATIONID: flatbuffers::VOffsetT = 6;
    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn requestId(&self) -> &'a super::org::enso::EnsoUUID {
    self._tab.get::<super::util::EnsoUUID>(OutboundMessage::VT_REQUESTID, None).unwrap()
  }
  #[inline]
  pub fn correlationId(&self) -> Option<&'a super::util::EnsoUUID> {
    self._tab.get::<super::util::EnsoUUID>(OutboundMessage::VT_CORRELATIONID, None)
  }
  #[inline]
  pub fn payload_type(&self) -> OutboundPayload {
    self._tab.get::<OutboundPayload>(OutboundMessage::VT_PAYLOAD_TYPE, Some(OutboundPayload::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(OutboundMessage::VT_PAYLOAD, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_error(&self) -> Option<super::util::Error<'a>> {
    if self.payload_type() == OutboundPayload::ERROR {
      self.payload().map(|u| super::util::Error::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_session_init_response(&self) -> Option<super::session::SessionInitResponse<'a>> {
    if self.payload_type() == OutboundPayload::SESSION_INIT_RESPONSE {
      self.payload().map(|u| super::session::SessionInitResponse::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_visualisation_update(&self) -> Option<super::executioncontext::VisualisationUpdate<'a>> {
    if self.payload_type() == OutboundPayload::VISUALISATION_UPDATE {
      self.payload().map(|u| super::executioncontext::VisualisationUpdate::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct OutboundMessageArgs<'a> {
    pub requestId: Option<&'a  super::util::EnsoUUID>,
    pub correlationId: Option<&'a  super::util::EnsoUUID>,
    pub payload_type: OutboundPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for OutboundMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        OutboundMessageArgs {
            requestId: None, // required field
            correlationId: None,
            payload_type: OutboundPayload::NONE,
            payload: None, // required field
        }
    }
}
pub struct OutboundMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutboundMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_requestId(&mut self, requestId: &'b  super::util::EnsoUUID) {
    self.fbb_.push_slot_always::<&super::util::EnsoUUID>(OutboundMessage::VT_REQUESTID, requestId);
  }
  #[inline]
  pub fn add_correlationId(&mut self, correlationId: &'b  super::util::EnsoUUID) {
    self.fbb_.push_slot_always::<&super::util::EnsoUUID>(OutboundMessage::VT_CORRELATIONID, correlationId);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: OutboundPayload) {
    self.fbb_.push_slot::<OutboundPayload>(OutboundMessage::VT_PAYLOAD_TYPE, payload_type, OutboundPayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutboundMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutboundMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OutboundMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutboundMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, OutboundMessage::VT_REQUESTID,"request_id");
    self.fbb_.required(o, OutboundMessage::VT_PAYLOAD,"payload");
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod envelope
}  // pub mod data
}  // pub mod protocol
}  // pub mod languageserver
}  // pub mod enso
}  // pub mod org

