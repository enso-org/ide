//! Crate containing the Engine Services binary protocol interface.

#[allow(dead_code, unused_imports)]
use flatbuffers;

use enso_prelude::*;

use futures::FutureExt;
use futures::StreamExt;
use futures::Stream;
use futures::channel::mpsc::unbounded;
use futures::channel::mpsc::UnboundedSender;
use futures::channel::oneshot;
use uuid::Uuid;

pub mod generated;

pub use generated::binary_protocol_generated as binary_protocol;
use json_rpc::{Transport, TransportEvent};
use crate::generated::binary_protocol_generated::org::enso::languageserver::protocol::binary::EnsoUUID;

use enso_protocol::language_server::Path as LSPath;

trait Handler {
    type Notification;
    type MessageID;

}

type Id = uuid::Uuid;

////////////////////////////////////////////////


fn most_significant_bits(uuid:Uuid) -> i64 {
    i64::from_be_bytes(uuid.as_bytes()[..8].try_into().unwrap())
}

fn least_significant_bits(uuid:Uuid) -> i64 {
    i64::from_be_bytes(uuid.as_bytes()[8..].try_into().unwrap())
}

impl From<Uuid> for EnsoUUID {
    fn from(uuid: Uuid) -> Self {
        EnsoUUID::new(least_significant_bits(uuid) as u64, most_significant_bits(uuid) as u64)
    }
}

impl From<EnsoUUID> for Uuid {
    fn from(uuid: EnsoUUID) -> Self {
        let most_significant_bytes = uuid.mostSigBits().to_le_bytes();
        let least_significant_bytes = uuid.leastSigBits().to_le_bytes();

        let mut bytes : [u8;16] = [0;16];
        bytes[0..8].copy_from_slice(&most_significant_bytes);
        bytes[8..16].copy_from_slice(&least_significant_bytes);
        Uuid::from_bytes(bytes)
    }
}

impl From<&Uuid> for EnsoUUID {
    fn from(uuid: &Uuid) -> Self {
        EnsoUUID::new(least_significant_bits(*uuid) as u64, most_significant_bits(*uuid) as u64)
    }
}

impl From<&EnsoUUID> for Uuid {
    fn from(uuid: &EnsoUUID) -> Self {
        let most_significant_bytes = uuid.mostSigBits().to_le_bytes();
        let least_significant_bytes = uuid.leastSigBits().to_le_bytes();

        let mut bytes : [u8;16] = [0;16];
        bytes[0..8].copy_from_slice(&most_significant_bytes);
        bytes[8..16].copy_from_slice(&least_significant_bytes);
        Uuid::from_bytes(bytes)
    }
}

impl EnsoUUID {
    fn new_v4() -> EnsoUUID {
        Uuid::new_v4().into()
    }
}

/// Message generated by server.
pub enum Message {
    RemoteError{
        code:u8,
        message:String,
    },
    VisualisationUpdate{
        visualisation_context:VisualisationContext,
        data:Vec<u8>,
    },
}

pub struct VisualisationContext {
    pub visualization_id : Uuid,
    pub context_id : Uuid,
    pub expression_id : Uuid,
}


//
// struct Client<Reply> {
//     transport:Box<dyn Transport>,
//     ongoing_requests:HashMap<Id,oneshot::Sender<Reply>>,
// }


struct BinaryClient {
    transport:Box<dyn Transport>,

}

impl BinaryClient {

}

use binary_protocol::org::enso::languageserver::protocol::binary::*;
use flatbuffers::{FlatBufferBuilder, WIPOffset, UnionWIPOffset};
use crate::generated::binary_protocol_generated::org::enso::languageserver::protocol::binary::InboundPayload::INIT_SESSION_CMD;
use std::future::Future;
use utils::fail::FallibleResult;

pub fn inbound_message
(builder:&mut flatbuffers::FlatBufferBuilder
, payload_type:InboundPayload
, payload:flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) -> EnsoUUID {
    let message_id = EnsoUUID::new_v4();
    let message = InboundMessage::create(builder, &InboundMessageArgs {
        correlationId : None,
        messageId     : Some(&message_id),
        payload_type  : payload_type,
        payload       : Some(payload),
    });
    builder.finish(message,None);
    message_id
}

type Payload = flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>;

pub fn with_new_message
( payload_type:InboundPayload
, make_payload: impl FnOnce(&mut FlatBufferBuilder) -> Payload
, consumer:impl FnOnce(&[u8])
) -> EnsoUUID {
    let mut builder = flatbuffers::FlatBufferBuilder::new_with_capacity(1024);
    let payload = Some(make_payload(&mut builder));

    let message_id = EnsoUUID::new_v4();
    let message    = InboundMessage::create(&mut builder, &InboundMessageArgs {
        correlationId : None,
        messageId     : Some(&message_id),
        payload_type,
        payload,
    });
    builder.finish(message,None);
    let serialized_message = builder.finished_data(); // Of type `&[u8]`
    consumer(serialized_message);
    message_id
}

pub fn with_new_message2<T>
( payload_type:InboundPayload
  , make_payload: impl FnOnce(&mut FlatBufferBuilder) -> WIPOffset<T>
  , consumer:impl FnOnce(&[u8])
) -> EnsoUUID {
    let mut builder = flatbuffers::FlatBufferBuilder::new_with_capacity(1024);
    let payload = Some(make_payload(&mut builder).as_union_value());

    let message_id = EnsoUUID::new_v4();
    let message    = InboundMessage::create(&mut builder, &InboundMessageArgs {
        correlationId : None,
        messageId     : Some(&message_id),
        payload_type,
        payload,
    });
    builder.finish(message,None);
    let serialized_message = builder.finished_data(); // Of type `&[u8]`
    consumer(serialized_message);
    message_id
}

pub fn serialize_path<'a>(path:&LSPath, builder:&mut FlatBufferBuilder<'a>) -> WIPOffset<Path<'a>> {
    let root_id      = path.root_id.into();
    let segment_refs = path.segments.iter().map(|s| s.as_str()).collect_vec();
    let segments     = builder.create_vector_of_strings(&segment_refs);
    Path::create(builder, &PathArgs {
        rootId : Some(&root_id),
        segments : Some(segments),
    })
}


pub fn with_init_request(client_id:EnsoUUID, consumer:impl FnOnce(&[u8])) -> EnsoUUID {
    let make_payload = |builder:&mut FlatBufferBuilder| {
        InitSessionCommand::create(builder, &InitSessionCommandArgs {
            identifier : Some(&client_id)
        }).as_union_value()
    };
    with_new_message(InboundPayload::INIT_SESSION_CMD,make_payload,consumer)
}

pub fn with_read_file_request(path:&LSPath, consumer:impl FnOnce(&[u8])) -> EnsoUUID {
    let make_payload = |builder:&mut FlatBufferBuilder| {
        let path = serialize_path(path,builder);
        ReadFileCommand::create(builder, &ReadFileCommandArgs {
            path : Some(path)
        }).as_union_value()
    };
    with_new_message(InboundPayload::READ_FILE_CMD,make_payload,consumer)
}

pub fn with_write_file_request(path:&LSPath, contents:&[u8], consumer:impl FnOnce(&[u8])) -> EnsoUUID {
    let make_payload = |builder:&mut FlatBufferBuilder| {
        let path     = serialize_path(path,builder);
        let contents = builder.create_vector(contents);
        WriteFileCommand::create(builder, &WriteFileCommandArgs {
            path : Some(path),
            contents : Some(contents),
        }).as_union_value()
    };
    with_new_message(InboundPayload::WRITE_FILE_CMD,make_payload,consumer)
}

struct VisualizationContext {
    visualization_id:Uuid, context_id:Uuid, expression_id:Uuid
}

pub enum FromServerOwned {
    Error {code:i32, message:String},
    Success {},
    VisualizationUpdate {context:VisualisationContext, data:Vec<u8>},
    FileContentsReply   {contents:Vec<u8>},
}

pub enum FromServer<'a> {
    Error {code:i32, message:&'a str},
    Success {},
    VisualizationUpdate {context:VisualisationContext, data:&'a [u8]},
    FileContentsReply {contents:&'a [u8]},
}

pub enum ToServer<'a> {
    InitSession {client_id:Uuid},
    WriteFile   {path:&'a LSPath, contents:&'a[u8]},
    ReadFile    {path:&'a LSPath}
}

struct Message2<T> {
    message_id:Uuid,
    correlation_id:Option<Uuid>,
    payload:T,
}

impl<T> Message2<T> where T:MessagePayload {
    fn write_message(&self, builder:&mut FlatBufferBuilder) {
        self.payload.write_message(builder, self.message_id, self.correlation_id)
    }

    fn write_buffer(&self) -> FlatBufferBuilder {
        let mut builder = flatbuffers::FlatBufferBuilder::new_with_capacity(1024);
        self.write_message(&mut builder);
        builder
    }

    fn with_message<R>(&self, f:impl FnOnce(&[u8]) -> R) -> R {
        let buffer = self.write_buffer();
        let data = buffer.finished_data();
        f(data)
    }
}

type MessageFromServerOwned = Message2<FromServerOwned>;

impl MessageFromServerOwned {
    fn deserialize<'a>(data:&'a [u8]) -> MessageFromServerOwned {
        let message = flatbuffers::get_root::<OutboundMessage<'a>>(data);
        let payload = match message.payload_type() {
            OutboundPayload::ERROR => {
                let payload = message.payload_as_error().unwrap();
                FromServerOwned::Error {
                    code    : payload.code(),
                    message : payload.message().unwrap_or_default().to_string(),
                }
            }
            OutboundPayload::FILE_CONTENTS_REPLY => {
                let payload = message.payload_as_file_contents_reply().unwrap();
                FromServerOwned::FileContentsReply {
                    contents : Vec::from(payload.contents().unwrap_or_default())
                }
            }
            OutboundPayload::SUCCESS => FromServerOwned::Success {},
            OutboundPayload::VISUALISATION_UPDATE => {
                let payload = message.payload_as_visualisation_update().unwrap();
                let context = payload.visualisationContext();
                FromServerOwned::VisualizationUpdate {
                    data : Vec::from(payload.data()),
                    context : VisualisationContext {
                        context_id : context.contextId().into(),
                        expression_id : context.expressionId().into(),
                        visualization_id : context.visualisationId().into(),
                    }
                }
            }
            _ => { todo!() }
        };
        Message2 {
            message_id : message.messageId().into(),
            correlation_id : message.correlationId().map(|id| id.into()),
            payload
        }
    }
}

trait MessagePayload {
    type PayloadType;

    fn write_message(&self, builder:&mut FlatBufferBuilder, message_id:Uuid, correlation_id:Option<Uuid>);
    fn write_payload(&self, builder: &mut FlatBufferBuilder) -> WIPOffset<UnionWIPOffset>;
    fn payload_type(&self) -> Self::PayloadType;
}

impl<'a> MessagePayload for ToServer<'a> {
    type PayloadType = InboundPayload;

    fn write_message(&self, builder:&mut FlatBufferBuilder, message_id:Uuid, correlation_id:Option<Uuid>) {
        let payload_type   = self.payload_type();
        let payload        = Some(self.write_payload(builder));
        let correlation_id = correlation_id.map(EnsoUUID::from);
        let message        = InboundMessage::create(builder, &InboundMessageArgs {
            correlationId : correlation_id.as_ref(),
            messageId     : Some(&message_id.into()),
            payload_type,
            payload,
        });
        builder.finish(message,None);
    }

    fn write_payload(&self, builder: &mut FlatBufferBuilder) -> WIPOffset<UnionWIPOffset> {
        match self {
            ToServer::InitSession {client_id} => {
                InitSessionCommand::create(builder, &InitSessionCommandArgs {
                    identifier : Some(&client_id.into())
                }).as_union_value()
            }
            ToServer::WriteFile {path,contents} => {
                let path     = serialize_path(path,builder);
                let contents = builder.create_vector(contents);
                WriteFileCommand::create(builder, &WriteFileCommandArgs {
                    path : Some(path),
                    contents : Some(contents),
                }).as_union_value()
            }
            ToServer::ReadFile {path} => {
                let path = serialize_path(path,builder);
                ReadFileCommand::create(builder, &ReadFileCommandArgs {
                    path : Some(path)
                }).as_union_value()
            }
        }
    }

    fn payload_type(&self) -> InboundPayload {
        match self {
            ToServer::InitSession {..} => InboundPayload::INIT_SESSION_CMD,
            ToServer::WriteFile   {..} => InboundPayload::WRITE_FILE_CMD,
            ToServer::ReadFile    {..} => InboundPayload::READ_FILE_CMD,
        }
    }
}

/// When trying to parse a line, not a single line was produced.
#[derive(Debug,Fail,Clone,Copy)]
#[fail(display = "No active request by id {}", _0)]
pub struct NoSuchRequest<Id : Sync + Send + Debug + Display + 'static>(Id);

#[derive(Debug,Default)]
struct RequestHandler<Id,Reply>
where Id:Hash+Eq {
    ongoing_calls : Rc<RefCell<HashMap<Id,oneshot::Sender<Reply>>>>,
}

impl<Id,Reply> RequestHandler<Id,Reply>
where Id:Hash+Eq {
    pub fn new() -> RequestHandler<Id,Reply> {
        RequestHandler {
            ongoing_calls : Rc::new(RefCell::new(default()))
        }
    }

    pub fn remove_request(&self, id:&Id) -> Option<oneshot::Sender<Reply>> {
        with(self.ongoing_calls.borrow_mut(), |mut map| map.remove(id))
    }

    pub fn open_request(&self, id:Id, sender:oneshot::Sender<Reply>) {
        with(self.ongoing_calls.borrow_mut(), |mut map| {
            map.insert(id,sender);
        })
    }

    pub fn clear(&self) {
        with(self.ongoing_calls.borrow_mut(), |mut map| map.clear())
    }

    pub fn complete_request(&self, id:Id, reply:Reply) -> FallibleResult<()>
    where Id : Display + Debug + Send + Sync + 'static {
        if let Some(mut request) = self.remove_request(&id) {
            // Explicitly ignore error. Can happen only if the other side already dropped future
            // with the call result. In such case no one needs to be notified and we are fine.
            let _ = request.send(reply);
            Ok(())
        } else {
            Err(NoSuchRequest(id).into())
        }
    }
}

fn open_request<SendReq,H,F,R>(handler:H, id:Id, f:F, send_request:SendReq) -> impl Future<Output = FallibleResult<R>>
where
    H : HandlerLike,
    F : FnOnce(H::Reply) -> FallibleResult<R>,
    SendReq : FnOnce() -> FallibleResult<()> {
    let (sender, receiver) = oneshot::channel::<H::Reply>();
    let ret                = receiver.map(|result_or_cancel| {
        let result = result_or_cancel?;
        f(result)
    });

    handler.ongoing_calls().open_request(id.clone(),sender);
    if send_request().is_err() {
        handler.ongoing_calls().remove_request(&id);
    }
    ret
}

trait HandlerLike {
    type Id;
    type Reply;

    fn borrow_mut_transport(&self) -> RefMut<dyn Transport>;
    fn ongoing_calls(&self) -> &RequestHandler<Id,Self::Reply>;

    fn process_event(&self, event:TransportEvent);
    fn generate_next_id(&self) -> Self::Id;

    fn with_transport<R>(&self, f:impl FnOnce(&mut dyn Transport) -> R) -> R {
        let mut transport = self.borrow_mut_transport();
        f(transport.deref_mut())
    }

    fn send_binary_message(&self, data:&[u8]) -> FallibleResult<()> {
        self.with_transport(|t| t.send_binary(data))
    }
}

struct Client {
    transport: Rc<RefCell<dyn Transport>>,
    requests: RequestHandler<Uuid,FromServerOwned>,
}

impl HandlerLike for Client {
    type Id = Uuid;
    type Reply = FromServerOwned;

    fn process_event(&self, event:TransportEvent) {
        unimplemented!()
    }

    fn borrow_mut_transport(&self) -> RefMut<Transport> {
        self.transport.borrow_mut()
    }

    fn generate_next_id(&self) -> Self::Id {
        Uuid::new_v4()
    }

    fn ongoing_calls(&self) -> &RequestHandler<Id, Self::Reply> {
        &self.requests
    }
}

impl Client {
    fn new(mut transport:impl Transport + 'static) -> Client {
        Client {
            transport : Rc::new(RefCell::new(transport)),
            requests : RequestHandler::new(),
        }
    }

    // fn transport_event_stream(&self) -> impl Stream<Item = TransportEvent> {
    //     let (event_transmitter, event_receiver) = unbounded();
    //     with(self.rc.borrow_mut(), |mut data| {
    //         data.transport.set_event_transmitter(event_transmitter);
    //     });
    //     event_receiver
    // }

    // /// Processes a single transport event.
    // ///
    // /// Each event either completes a requests or is translated into `Event`.
    // pub fn process_event(&self, event:TransportEvent)
    //     where Notification: DeserializeOwned {
    //     match event {
    //         TransportEvent::TextMessage(msg) =>
    //             self.process_incoming_message(msg),
    //         TransportEvent::BinaryMessage(data) =>
    //             self.error_occurred(HandlingError::UnexpectedBinaryMessage(data)),
    //         TransportEvent::Opened => {}
    //         TransportEvent::Closed => {
    //             // Dropping all ongoing calls will cancel their futures.
    //             self.clear_ongoing_requests();
    //             self.emit_event(Event::Closed);
    //         }
    //     }
    // }
    //
    // pub fn runner(&mut self) -> impl Future<Output = ()> {
    //     let event_receiver  = self.transport_event_stream();
    //     let weak_data       = Rc::downgrade(&self.rc);
    //     event_receiver.for_each(move |event:TransportEvent| {
    //         let data_opt    = weak_data.clone().upgrade();
    //         let handler_opt = data_opt.map(|rc| Handler {rc});
    //         if let Some(handler) = handler_opt {
    //             handler.process_event(event)
    //         } else {
    //             // If the data is inaccessible, it is ok to just drop the event here.
    //         }
    //         futures::future::ready(())
    //     })
    // }
}

#[test]
fn fbs_test() {
    with_init_request(EnsoUUID::new_v4(), |data| {
        println!("Data: {:?}",data);
    });
}


#[cfg(test)]
mod tests {
    use wasm_bindgen_test::wasm_bindgen_test_configure;
    wasm_bindgen_test_configure!(run_in_browser);


    #[wasm_bindgen_test::wasm_bindgen_test(async)]
    #[allow(dead_code)]
    async fn first_real_test() {
        ensogl_system_web::set_stdout();
        assert!(false);
    }
}