// automatically generated by the FlatBuffers compiler, do not modify



use crate::util_generated::*;
use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod org {

  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod enso {

  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod languageserver {

  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod protocol {

  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod data {

  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod executioncontext {

  use crate::util_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

pub enum VisualisationContextOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct VisualisationContext<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VisualisationContext<'a> {
    type Inner = VisualisationContext<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> VisualisationContext<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        VisualisationContext {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VisualisationContextArgs<'args>) -> flatbuffers::WIPOffset<VisualisationContext<'bldr>> {
      let mut builder = VisualisationContextBuilder::new(_fbb);
      if let Some(x) = args.expressionId { builder.add_expressionId(x); }
      if let Some(x) = args.contextId { builder.add_contextId(x); }
      if let Some(x) = args.visualisationId { builder.add_visualisationId(x); }
      builder.finish()
    }

    pub const VT_VISUALISATIONID: flatbuffers::VOffsetT = 4;
    pub const VT_CONTEXTID: flatbuffers::VOffsetT = 6;
    pub const VT_EXPRESSIONID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn visualisationId(&self) -> &'a super::util::EnsoUUID {
    self._tab.get::<super::util::EnsoUUID>(VisualisationContext::VT_VISUALISATIONID, None).unwrap()
  }
  #[inline]
  pub fn contextId(&self) -> &'a super::util::EnsoUUID {
    self._tab.get::<super::util::EnsoUUID>(VisualisationContext::VT_CONTEXTID, None).unwrap()
  }
  #[inline]
  pub fn expressionId(&self) -> &'a super::util::EnsoUUID {
    self._tab.get::<super::util::EnsoUUID>(VisualisationContext::VT_EXPRESSIONID, None).unwrap()
  }
}

pub struct VisualisationContextArgs<'a> {
    pub visualisationId: Option<&'a  super::util::EnsoUUID>,
    pub contextId: Option<&'a  super::util::EnsoUUID>,
    pub expressionId: Option<&'a  super::util::EnsoUUID>,
}
impl<'a> Default for VisualisationContextArgs<'a> {
    #[inline]
    fn default() -> Self {
        VisualisationContextArgs {
            visualisationId: None, // required field
            contextId: None, // required field
            expressionId: None, // required field
        }
    }
}
pub struct VisualisationContextBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VisualisationContextBuilder<'a, 'b> {
  #[inline]
  pub fn add_visualisationId(&mut self, visualisationId: &'b  super::util::EnsoUUID) {
    self.fbb_.push_slot_always::<&super::util::EnsoUUID>(VisualisationContext::VT_VISUALISATIONID, visualisationId);
  }
  #[inline]
  pub fn add_contextId(&mut self, contextId: &'b  super::util::EnsoUUID) {
    self.fbb_.push_slot_always::<&super::util::EnsoUUID>(VisualisationContext::VT_CONTEXTID, contextId);
  }
  #[inline]
  pub fn add_expressionId(&mut self, expressionId: &'b  super::util::EnsoUUID) {
    self.fbb_.push_slot_always::<&super::util::EnsoUUID>(VisualisationContext::VT_EXPRESSIONID, expressionId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VisualisationContextBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VisualisationContextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VisualisationContext<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, VisualisationContext::VT_VISUALISATIONID,"visualisation_id");
    self.fbb_.required(o, VisualisationContext::VT_CONTEXTID,"context_id");
    self.fbb_.required(o, VisualisationContext::VT_EXPRESSIONID,"expression_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum VisualisationUpdateOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct VisualisationUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VisualisationUpdate<'a> {
    type Inner = VisualisationUpdate<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> VisualisationUpdate<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        VisualisationUpdate {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VisualisationUpdateArgs<'args>) -> flatbuffers::WIPOffset<VisualisationUpdate<'bldr>> {
      let mut builder = VisualisationUpdateBuilder::new(_fbb);
      if let Some(x) = args.data { builder.add_data(x); }
      if let Some(x) = args.visualisationContext { builder.add_visualisationContext(x); }
      builder.finish()
    }

    pub const VT_VISUALISATIONCONTEXT: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn visualisationContext(&self) -> VisualisationContext<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<VisualisationContext<'a>>>(VisualisationUpdate::VT_VISUALISATIONCONTEXT, None).unwrap()
  }
  #[inline]
  pub fn data(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(VisualisationUpdate::VT_DATA, None).map(|v| v.safe_slice()).unwrap()
  }
}

pub struct VisualisationUpdateArgs<'a> {
    pub visualisationContext: Option<flatbuffers::WIPOffset<VisualisationContext<'a >>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for VisualisationUpdateArgs<'a> {
    #[inline]
    fn default() -> Self {
        VisualisationUpdateArgs {
            visualisationContext: None, // required field
            data: None, // required field
        }
    }
}
pub struct VisualisationUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VisualisationUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_visualisationContext(&mut self, visualisationContext: flatbuffers::WIPOffset<VisualisationContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VisualisationContext>>(VisualisationUpdate::VT_VISUALISATIONCONTEXT, visualisationContext);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VisualisationUpdate::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VisualisationUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VisualisationUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VisualisationUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, VisualisationUpdate::VT_VISUALISATIONCONTEXT,"visualisation_context");
    self.fbb_.required(o, VisualisationUpdate::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod executioncontext
}  // pub mod data
}  // pub mod protocol
}  // pub mod languageserver
}  // pub mod enso
}  // pub mod org

